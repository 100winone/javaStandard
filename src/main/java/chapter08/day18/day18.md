### 💡Day18 예외처리 - 예외처리
> 이 글은 남궁성님의 자바의 정석 3/e를 기반으로 공부한 내용을 정리한 글입니다.
>
> **소스정리**: https://github.com/100winone/javaStandard


```
컴파일 에러 - 컴파일 시에 발생하는 에러
런타임 에러 - 실행 시에 발생하는 에러
논리적 에러 - 실행은 되지만, 의도와 다르게 동작하는 것
```

```
소스코드 컴파일
-> 컴파일러가 소스코드(*.java)에 대한 오타, 잘못된 구문 등 기본적인 검사 수행하여 오류 있는지 체크
-> 컴파일 후에 클래스 파일(*.class) 생성되고, 생성된 클래스 파일을 실행할 수 있게 함
```

- 에러(error) : 프로그램 코드에 의해서 수습될 수 없는 심각한 오류
- 예외(exception) : 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류

#### 예외 클래스의 계층구조
```
                        Object
                        -> Throwable
->-> Exception                          ->-> Error
->->-> IOException, RuntimeException    ->->-> OutOfMemoryError
```

```
RuntimeException 클래스 - 프로그래머의 실수로 발생하는 예외
Exception 클래스 - 사용자의 실수와 같은 외적인 요인에 의해 발생하는 예외
```

#### 예외처리하기 - try-catch문
```
예외처리(exception handling)의
정의 - 프로그램 실행 시 발생할 수 있는 예외의 발생에 대비한 코드를 작성
목적 - 프로그램의 비정상 종료를 막고, 정상적인 실행상태를 유지
```

- 처리되지 못한 예외는 JVM의 '예외처리기'가 받아서 예외의 원인을 화면에 출력

```
> try블럭 내에서 예외가 발생한 경우
1. 발생한 예외와 일치하는 catch블럭이 있는지 확인
2. 일치하는 catch블럭을 찾게 되면, 그 catch블럭 내의 문장들을 수행하고 전체 try-catch문을 빠져나가서
   그 다음 문장을 계속해서 수행. 만일 일치하는 catch블럭을 찾지 못하면, 예외는 처리되지 못함

> try블럭 내에서 예외가 발생하지 않은 경우
1. catch블럭을 거치지 않고 전체 try-catch문을 빠져나가서 수행을 계속함   
```

```
printStackTrace() - 예외발생 당시의 호출스택(Call Stack)에 있었던 메서드의 정보와 예외 메시지를 화면에 출력
getMessage() - 발생한 예외클래스의 인스턴스에 저장된 메시지를 얻을 수 있음
```

#### 예외 발생시키기
```
1. 먼저, 연산자 new를 이용해서 발생시키려는 예외 클래스의 객체를 만든 다음
    Exception e = new Exception("고의로 발생시켰음");
2. 키워드 throw를 이용해서 예외 발생시킴
    throw e; 
```

#### finally블럭
>> 예외의 발생여부에 관계없이 항상 수행되어야하는 문장들을 넣음
```
예외발생 시 실행순서
    try -> catch -> finally

예외미발생 시 실행순서
    try -> finally
```

#### 예외 되던지기(exception re-throwing)
> 한 메서드에서 발생할 수 있는 예외가 여럿인 경우, 몇 개는 try-catch문을 통해서 메서드 내에서 자체적으로 처리하고, 그 나머지는 선언부에 지정하여 호출한 메서드에서 처리하도록 함으로써 나누어 처리하는 것

